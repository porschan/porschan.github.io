<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="porschan,710437653@qq.com"><title>Redis - 散列 · chanchifeng</title><meta name="description" content="散列（Hash）在前面的《字符串》一章中， 我们曾经看到过如何使用多个字符串键去储存相关联的一组数据。 比如在字符串键实现的文章储存程序中， 程序就会为每篇文章创建四个字符串键， 并把文章的标题、内容、作者和创建时间分别储存到这四个字符串键里面， 图 3-1 就展示了一个使用字符串键储存文章数据的例"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">chanchifeng</a></h3><div class="description"><p>备案/许可证编号：粤ICP备17106855号，工信部网站（http://www.beian.miit.gov.cn）</p></div></div></div><ul class="social-links"><li><a href="http://github.com/porschan"><i class="fa fa-github"></i></a></li></ul><div class="footer"></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li><li><a href="/readme">引导</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Redis - 散列</a></h3></div><div class="post-content"><h1 id="散列（Hash）"><a href="#散列（Hash）" class="headerlink" title="散列（Hash）"></a>散列（Hash）</h1><p>在前面的《字符串》一章中， 我们曾经看到过如何使用多个字符串键去储存相关联的一组数据。 比如在字符串键实现的文章储存程序中， 程序就会为每篇文章创建四个字符串键， 并把文章的标题、内容、作者和创建时间分别储存到这四个字符串键里面， 图 3-1 就展示了一个使用字符串键储存文章数据的例子。</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_cedaf54935e7afe9401d55886a74217a_r.png" alt></p>
<p>使用多个字符串键储存相关联数据虽然在技术上是可行的， 但是在实际应用中却并不是最有效的方法， 这种储存方法至少存在以下三个问题：</p>
<ul>
<li><p>首先， 程序每储存一组相关联的数据， 就必须在数据库里面同时创建多个字符串键， 这样的数据越多， 数据库包含的键数量也会越多。 数量庞大的键会对数据库某些操作的执行速度产生影响， 并且维护这些键也会产生大量的资源消耗。</p>
</li>
<li><p>其次， 为了在数据库里面标识出相关联的字符串键， 程序需要为它们加上相同的前缀， 但键名实际上也是一种数据， 储存键名也需要耗费内存空间， 因此重复出现的键名前缀实际上导致很多内存空间被白白浪费了。 此外， 带前缀的键名还降低了键名的可读性， 让人无法一眼看清键的真正用途， 比如键名 article::10086::author 就远不如键名 author 简洁， 而键名 article::10086::title 也远不如键名 title 来得简洁。</p>
</li>
<li><p>最后， 虽然程序在逻辑上会把带有相同前缀的字符串键看作是相关联的一组数据， 但是在 Redis 看来， 它们只不过是储存在同一个数据库中的不同字符串键而已。 因此当程序需要处理一组相关联的数据时， 它就必须对所有有关的字符串键都执行相同的操作。 比如说， 如果程序想要删除 ID 为 10086 的文章， 那么它就必须把 article::10086::title 、 article::10086::content 等四个字符串键都删掉才行， 这给文章的删除操作带来了额外的麻烦， 并且还可能会因为漏删或者错删了某个键而发生错误。</p>
</li>
</ul>
<p>为了解决以上问题， 我们需要一种能够真正地把相关联的数据打包起来储存的数据结构， 而这种数据结构就是本章要介绍的散列键。</p>
<h3 id="散列简介"><a href="#散列简介" class="headerlink" title="散列简介"></a>散列简介</h3><p>Redis 的散列键会将一个键和一个散列在数据库里面关联起来， 用户可以在散列里面为任意多个字段（field）设置值。 跟字符串键一样， 散列的字段和值既可以是文本数据， 也可以是二进制数据。</p>
<p>通过使用散列键， 用户可以把相关联的多项数据储存到同一个散列里面， 以便对这些数据进行管理， 又或者针对它们执行批量操作。 比如图 3-2 就展示了一个使用散列储存文章数据的例子， 在这个例子中， 散列的键为 article::10086 ， 而这个键对应的散列则包含了四个字段， 其中：</p>
<ul>
<li><p>“title” 字段储存着文章的标题 “greeting” ；</p>
</li>
<li><p>“content” 字段储存着文章的内容 “hello world” ；</p>
</li>
<li><p>“author” 字段储存着文章的作者名字 “peter” ；</p>
</li>
<li><p>“create_at” 字段储存着文章的创建时间 “1442744762.631885” 。</p>
</li>
</ul>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_5b1e41bc2f191936b48a307435fbc5de_r.png" alt></p>
<p>与之前使用字符串键储存文章数据的做法相比， 使用散列储存文章数据只需要在数据库里面创建一个键， 并且因为散列的字段名不需要添加任何前缀， 所以它们可以直接反映字段值储存的是什么数据。</p>
<p>Redis 为散列键提供了一系列操作命令， 通过使用这些命令， 用户可以：</p>
<ul>
<li><p>为散列的字段设置值， 又或者只在字段不存在的情况下为它设置值。</p>
</li>
<li><p>从散列里面获取给定字段的值。</p>
</li>
<li><p>对储存着数字值的字段执行加法操作或者减法操作。</p>
</li>
<li><p>检查给定字段是否存在于散列当中。</p>
</li>
<li><p>从散列里面删除指定字段。</p>
</li>
<li><p>查看散列包含的字段数量。</p>
</li>
<li><p>一次为散列的多个字段设置值， 又或者一次从散列里面获取多个字段的值。</p>
</li>
<li><p>获取散列包含的所有字段、所有值又或者所有字段和值。</p>
</li>
</ul>
<p>本章接下来将对以上提到的散列操作进行介绍， 说明如何使用这些操作去构建各种有用的应用程序， 并在最后详细地说明散列键与字符串键之间的区别。</p>
<h3 id="HSET：为字段设置值"><a href="#HSET：为字段设置值" class="headerlink" title="HSET：为字段设置值"></a>HSET：为字段设置值</h3><p>用户可以通过执行 HSET 命令， 为散列中的指定字段设置值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET hash field value</span><br></pre></td></tr></table></figure>
<p>根据给定的字段是否已经存在于散列里面， HSET 命令的行为也会有所不同：</p>
<ul>
<li><p>如果给定字段并不存在于散列当中， 那么这次设置就是一次创建操作， 命令将在散列里面关联起给定的字段和值， 然后返回 1 。</p>
</li>
<li><p>如果给定的字段原本已经存在于散列里面， 那么这次设置就是一次更新操作， 命令将使用用户给定的新值去覆盖字段原有的旧值， 然后返回 0 。</p>
</li>
</ul>
<p>举个例子， 通过执行以下 HSET 命令， 我们可以创建出一个包含了四个字段的散列， 这四个字段分别储存了文章的标题、内容、作者以及创建日期：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET article::10086 title &quot;greeting&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSET article::10086 content &quot;hello world&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSET article::10086 author &quot;peter&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSET article::10086 created_at &quot;1442744762.631885&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>HSET 命令执行之前的数据库， article::10086 散列并不存在</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_d00c4da6a6fe154c6ae9bad779f43f42_r.png" alt></p>
<p>执行 HSET article::10086 title “greeting” 命令之后</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_f1a6f24751fa03eb4d842922ed0b9fbd_r.png" alt></p>
<p>执行 HSET article::10086 content “hello world” 命令之后</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_da2bfbf4223cf2184a0bdf234c48fa25_r.png" alt></p>
<p>执行 HSET article::10086 author “peter” 命令之后</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_244b9c743474f6872585fb3520ceb05c_r.png" alt></p>
<p>执行 HSET article::10086 created_at “1442744762.631885” 命令之后</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_bcefe9da045b0d9d364a3c188397a0ac_r.png" alt></p>
<p>散列包含的字段就跟数据库包含的键一样， 在实际中都是以无序方式进行排列的， 不过本书为了展示方便， 一般都会把新字段添加到散列的末尾， 排在所有已有字段的后面。</p>
<p>使用新值覆盖旧值<br>正如之前所说， 如果用户在调用 HSET 命令时， 给定的字段已经存在于散列当中， 那么 HSET 命令将使用用户给定的新值去覆盖字段已有的旧值， 并返回 0 表示这是一次更新操作。</p>
<p>比如说， 以下代码就展示了如何使用 HSET 命令去更新 article::10086 散列的 title 字段以及 content 字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET article::10086 title &quot;Redis Tutorial&quot;</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; HSET article::10086 content &quot;Redis is a data structure store, ...&quot;</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
<p>被更新之后的 article::10086 散列</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_9b6540600c71fd91193240b0d73cde26_r.png" alt></p>
<h3 id="HSETNX：只在字段不存在的情况下为它设置值"><a href="#HSETNX：只在字段不存在的情况下为它设置值" class="headerlink" title="HSETNX：只在字段不存在的情况下为它设置值"></a>HSETNX：只在字段不存在的情况下为它设置值</h3><p>HSETNX 命令的作用和 HSET 命令的作用非常相似， 它们之间的区别在于， HSETNX 命令只会在指定字段不存在的情况下执行设置操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSETNX hash field value</span><br></pre></td></tr></table></figure>
<p>HSETNX 命令在字段不存在并且成功为它设置值时返回 1 ， 在字段已经存在并导致设置操作未能成功执行时返回 0 。</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_eeca77ec5fa2b4c08f878cd40564708c_r.png" alt></p>
<p>举个例子， 对于图 3-5 所示的 article::10086 散列来说， 执行以下 HSETNX 命令将不会对散列产生任何影响， 因为 HSETNX 命令想要设置的 title 字段已经存在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSETNX article::10086 title &quot;Redis Performance Test&quot;</span><br><span class="line">(integer) 0    -- 设置失败</span><br></pre></td></tr></table></figure>
<p>相反地， 如果我们使用 HSETNX 命令去对尚未存在的 view_count 字段进行设置， 那么这个命令将会顺利执行， 并将 view_count 字段的值设置为 100 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSETNX article::10086 view_count 100</span><br><span class="line">(integer) 1    -- 设置成功</span><br></pre></td></tr></table></figure>
<p>展示了 HSETNX 命令成功执行之后的 article::10086 散列。</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_94b42148f13a96839e44733c86702ee4_r.png" alt></p>
<h3 id="HGET：获取字段的值"><a href="#HGET：获取字段的值" class="headerlink" title="HGET：获取字段的值"></a>HGET：获取字段的值</h3><p>HGET 命令可以根据用户给定的字段， 从散列里面获取该字段的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGET hash field</span><br></pre></td></tr></table></figure>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_a8a65553607fdcd6863690e373f3b414_r.png" alt></p>
<p>比如对于图 3-7 所示的两个散列键来说， 执行以下命令可以从 article::10086 散列里面获取 author 字段的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HGET article::10086 author</span><br><span class="line">&quot;peter&quot;</span><br></pre></td></tr></table></figure>
<p>而执行以下命令则可以从 article::10086 散列里面获取 created_at 字段的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HGET article::10086 created_at</span><br><span class="line">&quot;1442744762.631885&quot;</span><br></pre></td></tr></table></figure>
<p>又比如说， 如果我们想要从 account::54321 散列里面获取 email 字段的值， 那么可以执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HGET account::54321 email</span><br><span class="line">&quot;peter1984@spam_mail.com&quot;</span><br></pre></td></tr></table></figure>
<p>处理不存在的字段或者不存在的散列<br>如果用户给定的字段并不存在于散列当中， 那么 HGET 命令将返回一个空值。</p>
<p>举个例子， 在以下代码中， 我们尝试从 account::54321 散列里面获取 location 字段的值， 但由于 location 字段并不存在于 account::54321 散列当中， 所以 HGET 命令将返回一个空值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HGET account::54321 location</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<p>尝试从一个不存在的散列里面获取一个不存在的字段值， 得到的结果也是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HGET not-exists-hash not-exists-field</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h3 id="示例：实现短网址生成程序"><a href="#示例：实现短网址生成程序" class="headerlink" title="示例：实现短网址生成程序"></a>示例：实现短网址生成程序</h3><p>为了给用户提供更多发言空间， 并记录用户在网站上的链接点击行为， 大部分社交网站都会将用户输入的网址转换为相应的短网址。 比如说， 如果我们在新浪微博发言时输入网址 <a href="http://redisdoc.com/geo/index.html" target="_blank" rel="noopener">http://redisdoc.com/geo/index.html</a> ， 那么微博将把这个网址转换为相应的短网址 <a href="http://t.cn/RqRRZ8n" target="_blank" rel="noopener">http://t.cn/RqRRZ8n</a> ， 当用户访问这个短网址时， 微博在后台就会对这次点击进行一些数据统计， 然后再引导用户的浏览器跳转到 <a href="http://redisdoc.com/geo/index.html" target="_blank" rel="noopener">http://redisdoc.com/geo/index.html</a> 上面。</p>
<p>创建短网址本质上就是要创建出短网址 ID 与目标网址之间的映射， 并在用户访问短网址时， 根据短网址的 ID 从映射记录中找出与之相对应的目标网址。 比如在前面的例子中， 微博的短网址程序就将短网址 <a href="http://t.cn/RqRRZ8n" target="_blank" rel="noopener">http://t.cn/RqRRZ8n</a> 中的 ID 值 RqRRZ8n 映射到了 <a href="http://redisdoc.com/geo/index.html" target="_blank" rel="noopener">http://redisdoc.com/geo/index.html</a> 这个网址上面： 当用户访问短网址 <a href="http://t.cn/RqRRZ8n" target="_blank" rel="noopener">http://t.cn/RqRRZ8n</a> 时， 程序就会根据这个短网址的 ID 值 RqRRZ8n ， 找出与之对应的目标网址 <a href="http://redisdoc.com/geo/index.html" target="_blank" rel="noopener">http://redisdoc.com/geo/index.html</a> ， 并将用户引导至目标网址上面去。</p>
<p>作为示例， 图 3-8 展示了几个微博短网址 ID 与目标网址之间的映射关系。</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_4fd551947a002e960d7eecc690e793b8_r.png" alt></p>
<p>因为 Redis 的散列正好就非常适合用来储存短网址 ID 与目标网址之间的映射， 所以我们可以基于 Redis 的散列实现一个短网址程序， 代码清单 3-1 展示了一个这样的例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> base36 <span class="keyword">import</span> base10_to_base36</span><br><span class="line"></span><br><span class="line">ID_COUNTER = <span class="string">"ShortyUrl::id_counter"</span></span><br><span class="line">URL_HASH = <span class="string">"ShortyUrl::url_hash"</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortyUrl</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, client)</span>:</span></span><br><span class="line">        self.client = client</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shorten</span><span class="params">(self, target_url)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        为目标网址创建并储存相应的短网址 ID 。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 为目标网址创建新的数字 ID</span></span><br><span class="line">        new_id = self.client.incr(ID_COUNTER)</span><br><span class="line">        <span class="comment"># 通过将 10 进制数字转换为 36 进制数字来创建短网址 ID</span></span><br><span class="line">        <span class="comment"># 比如说，10 进制数字 10086 将被转换为 36 进制数字 7S6</span></span><br><span class="line">        short_id = base10_to_base36(new_id)</span><br><span class="line">        <span class="comment"># 把短网址 ID 用作字段，目标网址用作值，</span></span><br><span class="line">        <span class="comment"># 将它们之间的映射关系储存到散列里面</span></span><br><span class="line">        self.client.hset(URL_HASH, short_id, target_url)</span><br><span class="line">        <span class="keyword">return</span> short_id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restore</span><span class="params">(self, short_id)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        根据给定的短网址 ID ，返回与之对应的目标网址。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.client.hget(URL_HASH, short_id)</span><br></pre></td></tr></table></figure>
<p>代码清单 3-2 将 10 进制数字转换成 36 进制数字的程序：/hash/base36.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base10_to_base36</span><span class="params">(number)</span>:</span></span><br><span class="line">    alphabets = <span class="string">"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span></span><br><span class="line">    result = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span> :</span><br><span class="line">        number, i = divmod(number, <span class="number">36</span>)</span><br><span class="line">        result = (alphabets[i] + result)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">or</span> alphabets[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>ShortyUrl 类的 shorten() 方法负责为输入的网址生成短网址 ID ， 它的工作包括以下四个步骤：</p>
<ol>
<li><p>为每个给定的网址创建一个 10 进制数字 ID 。</p>
</li>
<li><p>将 10 进制数字 ID 转换为 36 进制， 并将这个 36 进制数字用作给定网址的短网址 ID ， 这种方法在数字 ID 长度较大时可以有效地缩短数字 ID 的长度。 代码清单 3-2 展示了将数字从 10 进制转换成 36 进制的 base10_to_base36 函数的具体实现。</p>
</li>
<li><p>将短网址 ID 和目标网址之间的映射关系储存到散列里面。</p>
</li>
<li><p>向调用者返回刚刚生成的短网址 ID 。</p>
</li>
</ol>
<p>另一方面， restore() 方法要做的事情和 shorten() 方法正好相反： 它会从储存着映射关系的散列里面取出与给定短网址 ID 相对应的目标网址， 然后将其返回给调用者。</p>
<p>以下代码简单地展示了使用 ShortyUrl 程序创建短网址 ID 的方法， 以及根据短网址 ID 获取目标网址的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> shorty_url <span class="keyword">import</span> ShortyUrl</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client = Redis(decode_responses=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shorty_url = ShortyUrl(client)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shorty_url.shorten(<span class="string">"RedisGuide.com"</span>)  <span class="comment"># 创建短网址 ID</span></span><br><span class="line"><span class="string">'1'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shorty_url.shorten(<span class="string">"RedisBook.com"</span>)</span><br><span class="line"><span class="string">'2'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shorty_url.shorten(<span class="string">"RedisDoc.com"</span>)</span><br><span class="line"><span class="string">'3'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shorty_url.restore(<span class="string">"1"</span>)  <span class="comment"># 根据短网址 ID 查找目标网址</span></span><br><span class="line"><span class="string">'RedisGuide.com'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shorty_url.restore(<span class="string">"2"</span>)</span><br><span class="line"><span class="string">'RedisBook.com'</span></span><br></pre></td></tr></table></figure>
<p>展示了上面这段代码在数据库中创建的散列结构。</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_5c00226b77b16e5bc28428630b7828f8_r.png" alt></p>
<h3 id="HINCRBY：对字段储存的整数值执行加法或减法操作"><a href="#HINCRBY：对字段储存的整数值执行加法或减法操作" class="headerlink" title="HINCRBY：对字段储存的整数值执行加法或减法操作"></a>HINCRBY：对字段储存的整数值执行加法或减法操作</h3><p>跟字符串键的 INCRBY 命令一样， 如果散列的字段里面储存着能够被 Redis 解释为整数的数字， 那么用户就可以使用 HINCRBY 命令为该字段的值加上指定的整数增量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY hash field increment</span><br></pre></td></tr></table></figure>
<p>HINCRBY 命令在成功执行加法操作之后将返回字段当前的值作为命令的结果。</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_c3b7a73a3e1d23d4cc69bc5e06f6205d_r.png" alt></p>
<p>比如说， 对于图 3-10 所示的 article::10086 散列， 我们可以通过执行以下命令， 为 view_count 字段的值加上 1 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HINCRBY article::10086 view_count 1</span><br><span class="line">(integer) 101</span><br></pre></td></tr></table></figure>
<p>也可以通过执行以下命令， 为 view_count 字段的值加上 30 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HINCRBY article::10086 view_count 30</span><br><span class="line">(integer) 131</span><br></pre></td></tr></table></figure>
<p>执行减法操作<br>因为 Redis 只为散列提供了用于执行加法操作的 HINCRBY 命令， 但是却并没有为散列提供相应的用于执行减法操作的命令， 所以如果用户需要对字段储存的整数值执行减法操作的话， 那么他就需要将一个负数增量传给 HINCRBY 命令， 从而达到对值执行减法计算的目的。</p>
<p>以下代码展示了如何使用 HINCRBY 命令去对 view_count 字段储存的整数值执行减法计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HGET article::10086 view_count           -- 文章现在的浏览次数为 131 次</span><br><span class="line">&quot;131&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; HINCRBY article::10086 view_count -10    -- 将文章的浏览次数减少 10 次</span><br><span class="line">&quot;121&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; HINCRBY article::10086 view_count -21    -- 将文章的浏览次数减少 21 次</span><br><span class="line">&quot;100&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; HGET article::10086 view_count           -- 文章现在的浏览次数只有 100 次了</span><br><span class="line">&quot;100&quot;</span><br></pre></td></tr></table></figure>
<p>处理异常情况<br>HINCRBY 命令只能对储存着整数值的字段执行， 并且用户给定的增量也必须为整数， 尝试对非整数值字段执行 HINCRBY 命令， 又或者向 HINCRBY 命令提供非整数增量， 都会导致 HINCRBY 命令拒绝执行并报告错误。</p>
<p>以下是一些导致 HINCRBY 命令报错的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HINCRBY article::10086 view_count &quot;fifty&quot;    -- 增量必须能够被解释为整数</span><br><span class="line">(error) ERR value is not an integer or out of range</span><br><span class="line"></span><br><span class="line">redis&gt; HINCRBY article::10086 view_count 3.14       -- 增量不能是浮点数</span><br><span class="line">(error) ERR value is not an integer or out of range</span><br><span class="line"></span><br><span class="line">redis&gt; HINCRBY article::10086 content 100           -- 尝试向储存字符串值的字段执行 HINCRBY</span><br><span class="line">(error) ERR hash value is not an integer</span><br></pre></td></tr></table></figure>
<p>摘抄：<a href="http://redisguide.com/hash.html" title="Redis使用手册" target="_blank" rel="noopener">Redis使用手册</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-03-31</span><i class="fa fa-tag"></i></div></div></div></div><div class="cc"><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a></div><div class="cc_tips">本作品采用<a href="http://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a>进行许可。
<span id="busuanzi_container_page_pv"></span>本文总阅读量：<span id="busuanzi_value_page_pv"></span></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/03/14/202003272311/" title="Java - 枚举">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/busuanzi/busuanzi.pure.mini.js"></script></body></html>