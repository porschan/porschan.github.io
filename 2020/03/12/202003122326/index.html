<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="porschan,710437653@qq.com"><title>Redis - 字符串（String） · chanchifeng</title><meta name="description" content="字符串键是 Redis 最基本的键值对类型， 这种类型的键值对会在数据库里面把单独的一个键和单独的一个值关联起来， 被关联的键和值既可以是普通的文字数据， 也可以是图片、视频、音频、压缩文件等更为复杂的二进制数据。
Redis 为字符串键提供了一系列操作命令， 通过使用这些命令， 用户可以：

为字"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">chanchifeng</a></h3><div class="description"><p>备案/许可证编号：粤ICP备17106855号，工信部网站（http://www.beian.miit.gov.cn）</p></div></div></div><ul class="social-links"><li><a href="http://github.com/porschan"><i class="fa fa-github"></i></a></li></ul><div class="footer"></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li><li><a href="/readme">引导</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Redis - 字符串（String）</a></h3></div><div class="post-content"><p>字符串键是 Redis 最基本的键值对类型， 这种类型的键值对会在数据库里面把单独的一个键和单独的一个值关联起来， 被关联的键和值既可以是普通的文字数据， 也可以是图片、视频、音频、压缩文件等更为复杂的二进制数据。</p>
<p>Redis 为字符串键提供了一系列操作命令， 通过使用这些命令， 用户可以：</p>
<ul>
<li>为字符串键设置值。</li>
<li>获取字符串键的值。</li>
<li>在获取旧值的同时为字符串键设置新值。</li>
<li>同时为多个字符串键设置值，或者同时获取多个字符串键的值。</li>
<li>取得字符串值的长度。</li>
<li>获取字符串值指定索引范围上的内容，或者对字符串值指定索引范围上的内容进行修改。</li>
<li>将一些内容追加到字符串值的末尾。</li>
<li>对字符串键储存的整数值或者浮点数值执行加法操作或减法操作。</li>
</ul>
<h1 id="SET：为字符串键设置值"><a href="#SET：为字符串键设置值" class="headerlink" title="SET：为字符串键设置值"></a>SET：为字符串键设置值</h1><p>创建字符串键最常用的方法就是使用 SET 命令， 这个命令可以为一个字符串键设置相应的值。 在最基本的情况下， 用户只需要向 SET 命令提供一个键和一个值就可以了：</p>
<p><code>SET key value</code></p>
<p>跟之前提到过的一样， 这里的键和值既可以是文字也可以是二进制数据。</p>
<p>SET 命令在成功创建字符串键之后将返回 OK 作为结果。 比如说， 通过执行以下命令， 我们可以创建出一个字符串键， 它的键为 “number” ， 值为 “10086” ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET number &quot;10086&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>数据库键的存放方式<br>为了方便阅读， 本书总会将数据库中新出现的键放置到已有键的下方。 比如在上面展示的数据库图 2-3 里面， 我们就将新添加的 “number” 键和 “book” 键放置到了已有键的下方。</p>
<p>在实际中， Redis 数据库是以无序的方式存放数据库键的， 一个新加入的键可能会出现在数据库的任何位置上， 因此我们在使用 Redis 的过程中不应该对键在数据库中的摆放位置做任何假设， 以免造成错误。</p>
<p>改变覆盖规则</p>
<p>在默认情况下， 对一个已经设置了值的字符串键执行 SET 命令将导致键的旧值被新值覆盖。</p>
<p>举个例子， 如果我们连续执行以下两条 SET 命令， 那么第一条 SET 命令设置的值将被第二条 SET 命令设置的值所覆盖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET song_title &quot;Get Wild&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET song_title &quot;Running to Horizon&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>在第二条 SET 命令执行完毕之后， song_title 键的值将从原来的 “Get Wild” 变为 “Running to Horizon” 。</p>
<p>从 Redis 2.6.12 版本开始， 用户可以通过向 SET 命令提供可选的 NX 选项或者 XX 选项来指示 SET 命令是否要覆盖一个已经存在的值：</p>
<p><code>SET key value [NX|XX]</code></p>
<p>如果用户在执行 SET 命令时给定了 NX 选项， 那么 SET 命令只会在键没有值的情况下执行设置操作， 并返回 OK 表示设置成功； 如果键已经存在， 那么 SET 命令将放弃执行设置操作， 并返回空值 nil 表示设置失败。</p>
<p>以下代码展示了带有 NX 选项的 SET 命令的行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET password &quot;123456&quot; NX</span><br><span class="line">OK    -- 对尚未有值的 password 键进行设置，成功</span><br><span class="line"></span><br><span class="line">redis&gt; SET password &quot;999999&quot; NX</span><br><span class="line">(nil)    -- password 键已经有了值，设置失败</span><br></pre></td></tr></table></figure>
<p>因为第二条 SET 命令没有改变 password 键的值， 所以 password 键的值仍然是刚开始时设置的 “123456” 。</p>
<p>另一方面， 如果用户在执行 SET 命令时给定了 XX 选项， 那么 SET 命令只会在键已经有值的情况下执行设置操作， 并返回 OK 表示设置成功； 如果给定的键并没有值， 那么 SET 命令将放弃执行设置操作， 并返回空值表示设置失败。</p>
<p>举个例子， 如果我们对一个没有值的键 mongodb-homepage 执行以下 SET 命令， 那么命令将因为 XX 选项的作用而放弃执行设置操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mongodb-homepage &quot;mongodb.com&quot; XX</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<p>相反地， 如果我们对一个已经有值的键执行带有 XX 选项的 SET 命令， 那么命令将使用新值去覆盖已有的旧值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mysql-homepage &quot;mysql.org&quot;</span><br><span class="line">OK    -- 为键 mysql-homepage 设置一个值</span><br><span class="line"></span><br><span class="line">redis&gt; SET mysql-homepage &quot;mysql.com&quot; XX</span><br><span class="line">OK    -- 对键的值进行更新</span><br></pre></td></tr></table></figure>
<p>在第二条 SET 命令执行之后， mysql-homepage 键的值将从原来的 “mysql.org” 更新为 “mysql.com” 。</p>
<h1 id="GET：获取字符串键的值"><a href="#GET：获取字符串键的值" class="headerlink" title="GET：获取字符串键的值"></a>GET：获取字符串键的值</h1><p>用户可以通过使用 GET 命令， 从数据库里面获取指定字符串键的值：</p>
<p><code>GET key</code></p>
<p>GET 命令接受一个字符串键作为参数， 然后返回与该键相关联的值。</p>
<p>比如对于图 2-4 所示的数据库来说， 我们可以通过执行以下 GET 命令来取得各个字符串键相关联的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET message</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; GET number</span><br><span class="line">&quot;10086&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; GET homepage</span><br><span class="line">&quot;redis.io&quot;</span><br></pre></td></tr></table></figure>
<p>另一方面， 如果用户给定的字符串键在数据库中并没有与之相关联的值， 那么 GET 命令将返回一个空值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET date</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<p>上面这个 GET 命令的执行结果表示数据库中并不存在 date 键， 它也没有与之相关联的值。</p>
<p>因为 Redis 的数据库要求所有键必须拥有与之相关联的值， 所以如果一个键有值， 那么我们就说这个键存在于数据库； 相反地， 如果一个键没有值， 那么我们就说这个键不存在于数据库。 比如对于上面展示的几个键来说， date 键就不存在于数据库， 而 message 键、 number 键和 homepage 键则存在于数据库。</p>
<h1 id="GETSET：获取旧值并设置新值"><a href="#GETSET：获取旧值并设置新值" class="headerlink" title="GETSET：获取旧值并设置新值"></a>GETSET：获取旧值并设置新值</h1><p>GETSET 命令就像 GET 命令和 SET 命令的组合版本， 它首先获取字符串键目前已有的值， 接着为键设置新值， 最后把之前获取到的旧值返回给用户：</p>
<p><code>GETSET key new_value</code></p>
<p>以下代码展示了如何使用 GETSET 命令去获取 number 键的旧值并为它设置新值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET number    -- number 键现在的值为 &quot;10086&quot;</span><br><span class="line">&quot;10086&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; GETSET number &quot;12345&quot;</span><br><span class="line">&quot;10086&quot;    -- 返回旧值</span><br><span class="line"></span><br><span class="line">redis&gt; GET number    -- number 键的值已被更新为 &quot;12345&quot;</span><br><span class="line">&quot;12345&quot;</span><br></pre></td></tr></table></figure>
<p>另一方面， 如果被设置的键并不存在于数据库， 那么 GETSET 命令将返回空值作为键的旧值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET counter</span><br><span class="line">(nil)    -- 键不存在</span><br><span class="line"></span><br><span class="line">redis&gt; GETSET counter 50</span><br><span class="line">(nil)    -- 返回空值作为旧值</span><br><span class="line"></span><br><span class="line">redis&gt; GET counter</span><br><span class="line">&quot;50&quot;</span><br></pre></td></tr></table></figure>
<h1 id="示例：缓存"><a href="#示例：缓存" class="headerlink" title="示例：缓存"></a>示例：缓存</h1><p>对数据进行缓存是 Redis 最常见的用法之一： 因为 Redis 把数据储存在内存而不是硬盘上面， 并且访问内存数据的速度比访问硬盘数据的速度要快得多， 所以用户可以通过把需要快速访问的数据储存在 Redis 里面来提升应用程序访问这些数据时的速度。</p>
<p>代码清单 2-1 展示了一个使用 Redis 实现的缓存程序代码， 这个程序使用 SET 命令来将需要被缓存的数据储存到指定的字符串键里面， 并使用 GET 命令来从指定的字符串键里面获取被缓存的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, client)</span>:</span></span><br><span class="line">        self.client = client</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        把需要被缓存的数据储存到键 key 里面，</span></span><br><span class="line"><span class="string">        如果键 key 已经有值，那么使用新值去覆盖旧值。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.client.set(key, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取储存在键 key 里面的缓存数据，</span></span><br><span class="line"><span class="string">        如果数据不存在，那么返回 None 。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.client.get(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, key, new_value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        对键 key 储存的缓存数据进行更新，</span></span><br><span class="line"><span class="string">        并返回键 key 在被更新之前储存的缓存数据。</span></span><br><span class="line"><span class="string">        如果键 key 之前并没有储存数据，</span></span><br><span class="line"><span class="string">        那么返回 None 。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.client.getset(key, new_value)</span><br></pre></td></tr></table></figure>
<p>除了用于设置缓存的 set() 方法以及用于获取缓存的 get() 方法之外， 缓存程序还提供了由 GETSET 命令实现的 update() 方法： 这个方法可以让用户在对缓存进行设置的同时， 获得之前被缓存的旧值。 用户可以根据自己的需要决定是使用 set() 方法还是 update() 方法对缓存进行设置。</p>
<p>以下代码展示了怎样使用这个程序来缓存一个 HTML 页面， 并在有需要时获取它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> cache <span class="keyword">import</span> Cache</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client = Redis(decode_responses=<span class="literal">True</span>)  <span class="comment"># 使用文本编码方式打开客户端</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cache = Cache(client)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cache.set(<span class="string">"greeting-page"</span>, <span class="string">"&lt;html&gt;&lt;p&gt;hello world&lt;/p&gt;&lt;/html&gt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cache.get(<span class="string">"greeting-page"</span>)</span><br><span class="line"><span class="string">'&lt;html&gt;&lt;p&gt;hello world&lt;/p&gt;&lt;/html&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cache.update(<span class="string">"greeting-page"</span>, <span class="string">"&lt;html&gt;&lt;p&gt;good morning&lt;/p&gt;&lt;/html&gt;"</span>)</span><br><span class="line"><span class="string">'&lt;html&gt;&lt;p&gt;hello world&lt;/p&gt;&lt;/html&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cache.get(<span class="string">"greeting-page"</span>)</span><br><span class="line"><span class="string">'&lt;html&gt;&lt;p&gt;good morning&lt;/p&gt;&lt;/html&gt;'</span></span><br></pre></td></tr></table></figure>
<p>因为 Redis 的字符串键不仅可以储存文本数据， 还可以储存二进制数据， 所以这个缓存程序不仅可以用来缓存网页等文本数据， 还可以用来缓存图片和视频等二进制数据。 比如说， 如果你正在运营一个图片网站， 那么你同样可以使用这个缓存程序来缓存网站上的热门图片， 从而提高用户访问这些热门图片的速度。</p>
<p>作为例子， 以下代码展示了将 Redis 的 Logo 图片缓存到键 redis-logo.jpg 里面的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> cache <span class="keyword">import</span> Cache</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client = Redis()                      <span class="comment"># 使用二进制编码方式打开客户端</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cache = Cache(client)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image = open(<span class="string">"redis-logo.jpg"</span>, <span class="string">"rb"</span>)  <span class="comment"># 以二进制只读方式打开图片文件</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = image.read()                   <span class="comment"># 读取文件内容</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image.close()                         <span class="comment"># 关闭文件</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cache.set(<span class="string">"redis-logo.jpg"</span>, data)     <span class="comment"># 将内存缓存到键 redis-logo.jpg 里面</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cache.get(<span class="string">"redis-logo.jpg"</span>)[:<span class="number">20</span>]      <span class="comment"># 读取二进制数据的前 20 个字节</span></span><br><span class="line"><span class="string">b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x01\x00H\x00H\x00\x00'</span></span><br></pre></td></tr></table></figure>
<h1 id="示例：锁"><a href="#示例：锁" class="headerlink" title="示例：锁"></a>示例：锁</h1><p>锁是一种同步机制， 它可以保证一项资源在任何时候只能被一个进程使用， 如果有其他进程想要使用相同的资源， 那么它们就必须等待， 直到正在使用资源的进程放弃使用权为止。</p>
<p>一个锁实现通常会有获取（acquire）和释放（release）这两种操作：</p>
<ul>
<li><p>获取操作用于取得资源的独占使用权。 在任何时候， 最多只能有一个进程取得锁， 我们把成功取得锁的这个进程称之为锁的持有者。 在锁已经被持有的情况下， 所有尝试再次获取锁的操作都会失败。</p>
</li>
<li><p>释放操作用于放弃资源的独占使用权， 一般由锁的持有者调用。 在锁被释放之后， 其他进程就可以再次尝试获取这个锁了。</p>
</li>
</ul>
<p>以下展示了一个使用字符串键实现的锁程序， 这个程序会根据给定的字符串键是否有值来判断锁是否已经被获取， 而针对锁的获取操作和释放操作则是分别通过设置字符串键和删除字符串键来完成的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">VALUE_OF_LOCK = <span class="string">"locking"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, client, key)</span>:</span></span><br><span class="line">        self.client = client</span><br><span class="line">        self.key = key</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">acquire</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        尝试获取锁。</span></span><br><span class="line"><span class="string">        成功时返回 True ，失败时返回 False 。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = self.client.set(self.key, VALUE_OF_LOCK, nx=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> result <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">release</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        尝试释放锁。</span></span><br><span class="line"><span class="string">        成功时返回 True ，失败时返回 False 。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.client.delete(self.key) == <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>获取操作 acquire() 方法是通过执行带有 NX 选项的 SET 命令来实现的：</p>
<p><code>result = self.client.set(self.key, VALUE_OF_LOCK, nx=True)</code></p>
<p>NX 选项的效果确保了代表锁的字符串键只会在没有值的情况下被设置：</p>
<ul>
<li><p>如果给定的字符串键没有值， 那么说明锁尚未被获取， SET 命令将执行设置操作， 并将 result 变量的值设置为 True ；</p>
</li>
<li><p>与此相反， 如果给定的字符串键已经有值了， 那么说明锁已经被获取， SET 命令将放弃执行设置操作， 并将 result 变量的值将为 None ；</p>
</li>
</ul>
<p>acquire() 方法最后会通过检查 result 变量的值是否为 True 来判断自己是否成功取得了锁。</p>
<p>释放操作 release() 方法使用了本书之前没有介绍过的 DEL 命令， 这个命令接受一个或多个数据库键作为参数， 尝试删除这些键以及与之相关联的值， 并返回被成功删除的键数量作为结果：</p>
<p><code>DEL key [key ...]</code></p>
<p>因为 Redis 的 DEL 命令和 Python 的 del 关键字重名， 所以在 redis-py 客户端中， 执行 DEL 命令实际上是通过调用 delete() 方法来完成的：</p>
<p><code>self.client.delete(self.key) == 1</code></p>
<p>release() 方法通过检查 delete() 方法的返回值是否为 1 来判断删除操作是否执行成功： 如果用户尝试对一个尚未被获取的锁执行 release() 方法， 那么方法将返回 false ， 表示没有锁被释放。</p>
<p>在使用 DEL 命令删除代表锁的字符串键之后， 字符串键将重新回到没有值的状态， 这时用户就可以再次调用 acquire() 方法去获取锁了。</p>
<p>以下代码演示了这个锁的使用方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> lock <span class="keyword">import</span> Lock</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client = Redis(decode_responses=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lock = Lock(client, <span class="string">'test-lock'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lock.acquire()  <span class="comment"># 成功获取锁</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lock.acquire()  <span class="comment"># 锁已被获取，无法再次获取</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lock.release()  <span class="comment"># 释放锁</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lock.acquire()  <span class="comment"># 锁释放之后可以再次被获取</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>实现了基本的获取和释放功能， 但它并不完美：</p>
<ul>
<li><p>因为这个锁的释放操作无法验证进程的身份， 所以无论执行释放操作的进程是否就是锁的持有者， 锁都会被释放。 如果锁被持有者以外的其他进程释放了的话， 那么系统中可能就会同时出现多个锁， 导致锁的唯一性被破坏。</p>
</li>
<li><p>这个锁的获取操作不能设置最大加锁时间， 它无法让锁在超过给定的时限之后自动释放。 因此， 如果持有锁的进程因为故障或者编程错误而没有在退出之前主动释放锁， 那么锁就会一直处于已被获取的状态， 导致其他进程永远无法取得锁。</p>
</li>
</ul>
<h1 id="MSET：一次为多个字符串键设置值"><a href="#MSET：一次为多个字符串键设置值" class="headerlink" title="MSET：一次为多个字符串键设置值"></a>MSET：一次为多个字符串键设置值</h1><p>除了 SET 命令和 GETSET 命令之外， Redis 还提供了 MSET 命令用于对字符串键进行设置。 跟 SET 命令和 GETSET 命令只能设置单个字符串键的做法不同， MSET 命令可以一次为多个字符串键设置值：</p>
<p><code>MSET key value [key value ...]</code></p>
<p>作为例子， 以下代码展示了如何使用一条 MSET 命令去设置 message 、 number 和 homepage 三个键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSET message &quot;hello world&quot; number &quot;10086&quot; homepage &quot;redis.io&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET message</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; GET number</span><br><span class="line">&quot;10086&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; GET homepage</span><br><span class="line">&quot;redis.io&quot;</span><br></pre></td></tr></table></figure>
<p>跟 SET 命令一样， MSET 命令也会在执行设置操作之后返回 OK 表示设置成功。 此外， 如果给定的字符串键已经有相关联的值， 那么 MSET 命令也会直接使用新值去覆盖已有的旧值。</p>
<p>比如以下代码就展示了怎样使用 MSET 命令去覆盖上一个 MSET 命令为 message 键和 number 键设置的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSET message &quot;good morning!&quot; number &quot;12345&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET message</span><br><span class="line">&quot;good morning!&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; GET number</span><br><span class="line">&quot;12345&quot;</span><br></pre></td></tr></table></figure>
<p>MSET 命令除了可以让用户更为方便地执行多个设置操作之外， 还能够有效地提高程序的效率： 执行多条 SET 命令需要客户端和服务器之间进行多次网络通信， 并因此耗费大量的时间； 通过使用一条 MSET 命令去代替多条 SET 命令， 可以将原本所需的多次网络通信降低为只需一次网络通信， 从而有效地减少程序执行多个设置操作时所需的时间。</p>
<h1 id="MGET：一次获取多个字符串键的值"><a href="#MGET：一次获取多个字符串键的值" class="headerlink" title="MGET：一次获取多个字符串键的值"></a>MGET：一次获取多个字符串键的值</h1><p>MGET 命令就是一个多键版本的 GET 命令， 它接受一个或多个字符串键作为参数， 并返回这些字符串键的值：</p>
<p><code>MGET key [key ...]</code></p>
<p>MGET 命令返回一个列表作为结果， 这个列表按照用户执行命令时给定键的顺序排列各个键的值： 比如说， 列表的第一个元素就是第一个给定键的值， 而列表的第二个元素则是第二个给定键的值， 以此类推。</p>
<p>作为例子， 以下代码展示了如何使用一条 MGET 命令去获取 message 、 number 和 homepage 三个键的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MGET message number homepage</span><br><span class="line">1) &quot;hello world&quot;    -- message 键的值</span><br><span class="line">2) &quot;10086&quot;          -- number 键的值</span><br><span class="line">3) &quot;redis.io&quot;       -- homepage 键的值</span><br></pre></td></tr></table></figure>
<p>跟 GET 命令一样， MGET 命令在碰到不存在的键时也会返回空值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MGET not-exists-key</span><br><span class="line">1) (nil)</span><br></pre></td></tr></table></figure>
<p>跟 MSET 命令类似， MGET 命令也可以将执行多个获取操作所需的网络通信次数从原来的 N 次降低至只需一次， 从而有效地提高程序的运行效率。</p>
<h1 id="MSETNX：只在键不存在的情况下，一次为多个字符串键设置值"><a href="#MSETNX：只在键不存在的情况下，一次为多个字符串键设置值" class="headerlink" title="MSETNX：只在键不存在的情况下，一次为多个字符串键设置值"></a>MSETNX：只在键不存在的情况下，一次为多个字符串键设置值</h1><p>MSETNX 命令跟 MSET 命令一样， 都可以对多个字符串键进行设置：</p>
<p><code>MSETNX key value [key value ...]</code></p>
<p>MSETNX 跟 MSET 的主要区别在于 MSETNX 只会在所有给定键都不存在的情况下对键进行设置， 而不会像 MSET 那样直接覆盖键已有的值： 如果在给定键当中， 有哪怕一个键已经有值了， 那么 MSETNX 命令也会放弃对所有给定键的设置操作。 MSETNX 命令在成功执行设置操作时返回 1 ， 在放弃执行设置操作时则返回 0 。</p>
<p>在以下的这段代码中， 因为键 k4 已经存在， 所以 MSETNX 将放弃对键 k1 、 k2 、 k3 和 k4 进行设置操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MGET k1 k2 k3 k4</span><br><span class="line">1) (nil)            -- 键 k1 、 k2 和 k3 都不存在</span><br><span class="line">2) (nil)</span><br><span class="line">3) (nil)</span><br><span class="line">4) &quot;hello world&quot;    -- 键 k4 已存在</span><br><span class="line"></span><br><span class="line">redis&gt; MSETNX k1 &quot;one&quot; k2 &quot;two&quot; k3 &quot;three&quot; k4 &quot;four&quot;</span><br><span class="line">(integer) 0    -- 因为键 k4 已存在，所以 MSETNX 未能执行设置操作</span><br><span class="line"></span><br><span class="line">redis&gt; MGET k1 k2 k3 k4    -- 各个键的值没有变化</span><br><span class="line">1) (nil)</span><br><span class="line">2) (nil)</span><br><span class="line">3) (nil)</span><br><span class="line">4) &quot;hello world&quot;</span><br></pre></td></tr></table></figure>
<p>但是如果我们只对不存在的键 k1 、 k2 和 k3 进行设置， 那么 MSETNX 可以正常地完成设置操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSETNX k1 &quot;one&quot; k2 &quot;two&quot; k3 &quot;three&quot;</span><br><span class="line">(integer) 1    -- 所有给定键都不存在，成功执行设置操作</span><br><span class="line"></span><br><span class="line">redis&gt; MGET k1 k2 k3 k4</span><br><span class="line">1) &quot;one&quot;            -- 刚刚使用 MSETNX 设置的三个值</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;hello world&quot;    -- 之前已经存在的键 k4 的值没有改变</span><br></pre></td></tr></table></figure>
<h1 id="示例：储存文章信息"><a href="#示例：储存文章信息" class="headerlink" title="示例：储存文章信息"></a>示例：储存文章信息</h1><p>在构建应用程序的时候， 我们经常会需要批量地设置和获取多项信息。 以博客程序为例子：</p>
<ul>
<li><p>当用户想要注册成为博客的作者时， 程序就需要把这位作者的名字、账号、密码、注册时间等多项信息储存起来， 并在用户登录的时候取出这些信息。</p>
</li>
<li><p>又比如说， 当博客的作者想要撰写一篇新文章的时候， 程序就需要把文章的标题、内容、作者、发表时间等多项信息储存起来， 并在用户阅读文章的时候取出这些信息。</p>
</li>
</ul>
<p>通过使用 MSET 命令、 MSETNX 命令以及 MGET 命令， 我们可以实现上面提到的这些批量设置操作和批量获取操作。 比如代码清单 2-3 就展示了一个文章储存程序， 这个程序使用 MSET 命令和 MSETNX 命令将文章的标题、内容、作者、发表时间等多项信息储存到不同的字符串键里面， 并通过 MGET 命令从这些键里面获取文章的各项信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time  <span class="comment"># time() 函数用于获取当前 Unix 时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, client, article_id)</span>:</span></span><br><span class="line">        self.client = client</span><br><span class="line">        self.id = str(article_id)</span><br><span class="line">        self.title_key = <span class="string">"article::"</span> + self.id + <span class="string">"::title"</span></span><br><span class="line">        self.content_key = <span class="string">"article::"</span> + self.id + <span class="string">"::content"</span></span><br><span class="line">        self.author_key = <span class="string">"article::"</span> + self.id + <span class="string">"::author"</span></span><br><span class="line">        self.create_at_key = <span class="string">"article::"</span> + self.id + <span class="string">"::create_at"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, title, content, author)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        创建一篇新的文章，创建成功时返回 True ，</span></span><br><span class="line"><span class="string">        因为文章已存在而导致创建失败时返回 False 。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        article_data = &#123;</span><br><span class="line">            self.title_key: title,</span><br><span class="line">            self.content_key: content,</span><br><span class="line">            self.author_key: author,</span><br><span class="line">            self.create_at_key: time()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> self.client.msetnx(article_data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        返回 ID 对应的文章信息。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = self.client.mget(self.title_key,</span><br><span class="line">                                  self.content_key,</span><br><span class="line">                                  self.author_key,</span><br><span class="line">                                  self.create_at_key)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"id"</span>: self.id, <span class="string">"title"</span>: result[<span class="number">0</span>], <span class="string">"content"</span>: result[<span class="number">1</span>],</span><br><span class="line">                <span class="string">"author"</span>: result[<span class="number">2</span>], <span class="string">"create_at"</span>: result[<span class="number">3</span>]&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, title=None, content=None, author=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        对文章的各项信息进行更新，</span></span><br><span class="line"><span class="string">        更新成功时返回 True ，失败时返回 False 。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        article_data = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> title <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            article_data[self.title_key] = title</span><br><span class="line">        <span class="keyword">if</span> content <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            article_data[self.content_key] = content</span><br><span class="line">        <span class="keyword">if</span> author <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            article_data[self.author_key] = author</span><br><span class="line">        <span class="keyword">return</span> self.client.mset(article_data)</span><br></pre></td></tr></table></figure>
<p>这个文章储存程序比较长， 让我们来逐个分析它的各项功能。 首先， Article 类的初始化方法 <strong>init</strong>() 接受一个 Redis 客户端和一个文章 ID 作为参数， 并将文章 ID 从数字转换为字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.id = str(article_id)</span><br></pre></td></tr></table></figure>
<p>接着程序会使用这个字符串格式的文章 ID ， 构建出用于储存文章各项信息的字符串键的键名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.title_key = <span class="string">"article::"</span> + self.id + <span class="string">"::title"</span></span><br><span class="line">self.content_key = <span class="string">"article::"</span> + self.id + <span class="string">"::content"</span></span><br><span class="line">self.author_key = <span class="string">"article::"</span> + self.id + <span class="string">"::author"</span></span><br><span class="line">self.create_at_key = <span class="string">"article::"</span> + self.id + <span class="string">"::create_at"</span></span><br></pre></td></tr></table></figure>
<p>在这些键当中， 第一个键将用于储存文章的标题， 第二个键将用于储存文章的内容， 第三个键将用于储存文章的作者， 而第四个键则会用于储存文章的创建时间。</p>
<p>当用户想要根据给定的文章 ID 创建具体的文章时， 他就需要调用 create() 方法， 并传入文章的标题、内容以及作者作为参数。 create() 方法会把以上这些信息以及当前的 UNIX 时间戳放入到一个 Python 字典里面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">article_data = &#123;</span><br><span class="line">    self.title_key: title,</span><br><span class="line">    self.content_key: content,</span><br><span class="line">    self.author_key: author,</span><br><span class="line">    self.create_at_key: time()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>article_data 字典的键储存了代表文章各项信息的字符串键的键名， 而与这些键相关联的则是这些字符串键将要被设置的值。 接下来， 程序会调用 MSETNX 命令， 对字典中给定的字符串键进行设置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.client.msetnx(article_data)</span><br></pre></td></tr></table></figure>
<p>因为 create() 方法的设置操作是通过 MSETNX 命令来进行的， 所以这一操作只会在所有给定字符串键都不存在的情况下进行：</p>
<ul>
<li><p>如果给定的字符串键已经有值了， 那么说明与给定 ID 相对应的文章已经存在。 在这种情况下， MSETNX 命令将放弃执行设置操作， 并且 create() 方法也会向调用者返回 False 表示文章创建失败。</p>
</li>
<li><p>与此相反， 如果给定的字符串键尚未有值， 那么 create() 方法将根据用户给定的信息创建文章， 并在成功之后返回 True 。</p>
</li>
</ul>
<p>在成功创建文章之后， 用户就可以使用 get() 方法去获取文章的各项信息了。 get() 方法会调用 MGET 命令， 从各个字符串键里面取出文章的标题、内容、作者等信息， 并把这些信息储存到 result 列表中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = self.client.mget(self.title_key,</span><br><span class="line">                          self.content_key,</span><br><span class="line">                          self.author_key,</span><br><span class="line">                          self.create_at_key)</span><br></pre></td></tr></table></figure>
<p>为了让用户可以更方便地访问文章的各项信息， get() 方法会将储存在 result 列表里面的文章信息放入到一个字典里面， 然后再返回给用户：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;<span class="string">"id"</span>: self.id, <span class="string">"title"</span>: result[<span class="number">0</span>], <span class="string">"content"</span>: result[<span class="number">1</span>],</span><br><span class="line">        <span class="string">"author"</span>: result[<span class="number">2</span>], <span class="string">"create_at"</span>: result[<span class="number">3</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>这样做的好处有两点：</p>
<ol>
<li><p>它隐藏了 get() 方法由 MGET 命令实现这一底层细节。 如果程序直接向用户返回 result 列表， 那么用户就必须知道列表中的各个元素代表文章的哪一项信息， 然后通过列表索引来访问文章的各项信息。 这种做法非常不方便， 而且也非常容易出错。</p>
</li>
<li><p>返回一个字典可以让用户以 dict[key] 这样的方式去访问文章的各个属性， 比如使用 article[“title”] 去访问文章的标题， 使用 article[“content”] 去访问文章的内容， 诸如此类， 这使得针对文章数据的各项操作可以更方便地进行。</p>
</li>
</ol>
<p>另外要注意的一点是， 虽然用户可以通过访问 Article 类的 id 属性来获得文章的 ID ， 但是为了方便起见， get() 方法在返回文章信息的时候也会将文章的 ID 包含在字典里面一并返回。</p>
<p>对文章信息进行更新的 update() 方法是整个程序最复杂的部分。 首先， 为了让用户可以自由选择需要更新的信息项， 这个函数在定义时使用了 Python 的具名参数特性：</p>
<p>def update(self, title=None, content=None, author=None):</p>
<p>通过具名参数， 用户可以根据自己想要更新的文章信息项来决定传入哪个参数， 而不需要更新的信息项则会被赋予默认值 None ：</p>
<ul>
<li><p>比如说， 如果用户只想要更新文章的标题， 那么只需要调用 update(title=new_title) 即可；</p>
</li>
<li><p>又比如说， 如果用户想要同时更新文章的内容和作者， 那么只需要调用 update(content=new_content, author=new_author) 即可；</p>
</li>
</ul>
<p>诸如此类。</p>
<p>在定义了具名参数之后， update() 方法会检查各个参数的值， 并将那些不为 None 的参数以及与之相对应的字符串键键名放入到 article_data 字典里面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">article_data = &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> title <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    article_data[self.title_key] = title</span><br><span class="line"><span class="keyword">if</span> content <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    article_data[self.content_key] = content</span><br><span class="line"><span class="keyword">if</span> author <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    article_data[self.author_key] = author</span><br></pre></td></tr></table></figure>
<p>article_data 字典中的键就是需要更新的字符串键的键名， 而与之相关联的则是这些字符串键的新值。</p>
<p>在一切准备就绪之后， update() 方法会根据 article_data 字典中设置好的键值对， 调用 MSET 命令对文章进行更新：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.client.mset(article_data)</span><br></pre></td></tr></table></figure>
<p>以下代码展示了这个文章储存程序的使用方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> article <span class="keyword">import</span> Article</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client = Redis(decode_responses=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>article = Article(client, <span class="number">10086</span>)                   <span class="comment"># 指定文章 ID</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>article.create(<span class="string">'message'</span>, <span class="string">'hello world'</span>, <span class="string">'peter'</span>)  <span class="comment"># 创建文章</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>article.get()                                      <span class="comment"># 获取文章</span></span><br><span class="line">&#123;<span class="string">'id'</span>: <span class="string">'10086'</span>, <span class="string">'title'</span>: <span class="string">'message'</span>, <span class="string">'content'</span>: <span class="string">'hello world'</span>,</span><br><span class="line"> <span class="string">'author'</span>: <span class="string">'peter'</span>, <span class="string">'create_at'</span>: <span class="string">'1551199163.4296808'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>article.update(author=<span class="string">"john"</span>)                      <span class="comment"># 更新文章的作者</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>article.get()                                      <span class="comment"># 再次获取文章</span></span><br><span class="line">&#123;<span class="string">'id'</span>: <span class="string">'10086'</span>, <span class="string">'title'</span>: <span class="string">'message'</span>, <span class="string">'content'</span>: <span class="string">'hello world'</span>,</span><br><span class="line"> <span class="string">'author'</span>: <span class="string">'john'</span>, <span class="string">'create_at'</span>: <span class="string">'1551199163.4296808'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>键的命名格式</p>
<p>Article 程序使用了多个字符串键去储存文章信息， 并且每个字符串键的名字都是以 article::<id>::<attribute> 格式命名的， 这是一种 Redis 使用惯例： Redis 用户通常会为逻辑上相关联的键设置相同的前缀， 并通过分隔符来区分键名的各个部分， 以此来构建一种键的命名格式。</attribute></id></p>
<p>比如对于 article::10086::title 、 article::10086::author 这些键来说， article 前缀表明这些键都储存着与文章信息相关的数据， 而分隔符 :: 则区分开了键名里面的前缀、ID 以及具体的属性。 除了 :: 符号之外， 常用的键名分隔符还包括 . 符号， 比如 article.10086.title ； 或者 -&gt; 符号， 比如 article-&gt;10086-&gt;title ； 又或者 | 符号， 比如 article|10086|title ； 诸如此类。</p>
<p>分隔符的选择通常只是一个个人喜好的问题， 而键名的具体格式也可以根据需要进行构造： 比如说， 如果你不喜欢 article::<id>::<attribute> 格式， 那么也可以考虑使用 article::<attribute>::<id> 格式， 诸如此类。 唯一需要注意的是， 一个程序应该只使用一种键名分隔符， 并且持续地使用同一种键名格式， 以免造成混乱。</id></attribute></attribute></id></p>
<p>通过使用相同的格式去命名逻辑上相关联的键， 我们可以让程序产生的数据结构变得更容易被理解， 并且在有需要的时候， 还可以根据特定的键名格式， 在数据库里面以模式匹配的方式查找指定的键。</p>
<h1 id="STRLEN：获取字符串值的字节长度"><a href="#STRLEN：获取字符串值的字节长度" class="headerlink" title="STRLEN：获取字符串值的字节长度"></a>STRLEN：获取字符串值的字节长度</h1><p>通过对字符串键执行 STRLEN 命令， 用户可以取得字符串键储存的值的字节长度：</p>
<p><code>STRLEN key</code></p>
<p>以下代码展示了如何使用 STRLEN 去获取不同字符串值的字节长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET number</span><br><span class="line">&quot;10086&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; STRLEN number    -- number 键的值长 5 字节</span><br><span class="line">(integer) 5</span><br><span class="line"></span><br><span class="line">redis&gt; GET message</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; STRLEN message   -- message 键的值长 11 字节</span><br><span class="line">(integer) 11</span><br><span class="line"></span><br><span class="line">redis&gt; GET book</span><br><span class="line">&quot;The Design and Implementation of Redis&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; STRLEN book      -- book 键的值长 38 字节</span><br><span class="line">(integer) 38</span><br></pre></td></tr></table></figure>
<p>对于不存在的键， STRLEN 命令将返回 0 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; STRLEN not-exists-key</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
<h1 id="字符串值的索引"><a href="#字符串值的索引" class="headerlink" title="字符串值的索引"></a>字符串值的索引</h1><p>因为每个字符串都是由一系列连续的字节组成的， 所以字符串中的每个字节实际上都拥有与之相对应的索引。 Redis 为字符串键提供了一系列索引操作命令， 这些命令允许用户通过正数索引或者负数索引， 对字符串值的某个字节或者某个部分进行处理， 其中：</p>
<ul>
<li><p>字符串值的正数索引以 0 为开始， 从字符串的开头向结尾不断递增；</p>
</li>
<li><p>字符串值的负数索引以 -1 为开始， 从字符串的结尾向开头不断递减。</p>
<p>“hello world” 的字符串索引示例</p>
</li>
</ul>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_59db2300c4679ba882397f2221f7bda2_r.png" alt></p>
<h1 id="GETRANGE：获取字符串值指定索引范围上的内容"><a href="#GETRANGE：获取字符串值指定索引范围上的内容" class="headerlink" title="GETRANGE：获取字符串值指定索引范围上的内容"></a>GETRANGE：获取字符串值指定索引范围上的内容</h1><p>通过使用 GETRANGE 命令， 用户可以获取字符串值从 start 索引开始， 直到 end 索引为止的所有内容：</p>
<p><code>GETRANGE key start end</code></p>
<p>GETRANGE 命令接受的是闭区间索引范围， 也即是说， 位于 start 索引和 end 索引上的值也会被包含在命令返回的内容当中。</p>
<p>举个例子， 以下代码展示了如何使用 GETRANGE 命令去获取 message 键的值的不同部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GETRANGE message 0 4     -- 获取字符串值索引 0 至索引 4 上的内容</span><br><span class="line">&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; GETRANGE message 6 10    -- 获取字符串值索引 6 至索引 10 上的内容</span><br><span class="line">&quot;world&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; GETRANGE message 3 7     -- 获取字符串值的中间部分</span><br><span class="line">&quot;lo wo&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; GETRANGE message -11 -7  -- 使用负数索引获取指定内容</span><br><span class="line">&quot;hello&quot;</span><br></pre></td></tr></table></figure>
<p>GETRANGE 命令执行示例</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_c3aa0e4148e8ab7820c36e3f2844f5d7_r.png" alt></p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_37182aeb004706ce083e0328fc8f85db_r.png" alt></p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_34e08d2e4f5ef0252fa1072eb7e19eee_r.png" alt></p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_1faa6ab3f148e9145b9a4d0853c5af4f_r.png" alt></p>
<h1 id="SETRANGE：对字符串值的指定索引范围进行设置"><a href="#SETRANGE：对字符串值的指定索引范围进行设置" class="headerlink" title="SETRANGE：对字符串值的指定索引范围进行设置"></a>SETRANGE：对字符串值的指定索引范围进行设置</h1><p>通过使用 SETRANGE 命令， 用户可以将字符串键的值从索引 index 开始的部分替换为指定的新内容， 被替换内容的长度取决于新内容的长度：</p>
<p><code>SETRANGE key index substitute</code></p>
<p>SETRANGE 命令在执行完设置操作之后， 会返回字符串值当前的长度作为结果。</p>
<p>比如说， 我们可以通过执行以下命令， 将 message 键的值从原来的 “hello world” 修改为 “hello Redis” ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET message</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SETRANGE message 6 &quot;Redis&quot;</span><br><span class="line">(integer) 11    -- 字符串值当前的长度为 11 字节</span><br><span class="line"></span><br><span class="line">redis&gt; GET message</span><br><span class="line">&quot;hello Redis&quot;</span><br></pre></td></tr></table></figure>
<p>这个例子中的 SETRANGE 命令会将 message 键的值从索引 6 开始的内容替换为 “Redis” ， 图 2-7 展示了这个命令的执行过程。</p>
<p>SETRANGE 命令修改 message 键的过程</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_319141a85c9c073c9c2a730748d2ce8c_r.png" alt></p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_541d973fa4385157f1cffb926fc8380b_r.png" alt></p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_328e1a46f86a8e569c00571a58257c17_r.png" alt></p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_be7f10bc0e605cc2fe4e06fce97a953f_r.png" alt></p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_6564281c5f1b31ef4de1ff9e44166eda_r.png" alt></p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_f4ff69337de122b4f1d130637a572653_r.png" alt></p>
<p>自动扩展被修改的字符串</p>
<p>当用户给定的新内容比被替换的内容更长时， SETRANGE 命令就会自动扩展被修改的字符串值， 从而确保新内容可以顺利写入。</p>
<p>比如说， 以下代码就展示了如何通过 SETRANGE 命令， 将 message 键的值从原来的 11 字节长修改为 41 字节长：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET message</span><br><span class="line">&quot;hello Redis&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SETRANGE message 5 &quot;, this is a message send from peter.&quot;</span><br><span class="line">(integer) 41</span><br><span class="line"></span><br><span class="line">redis&gt; GET message</span><br><span class="line">&quot;hello, this is a message send from peter.&quot;</span><br></pre></td></tr></table></figure>
<p>SETRANGE 命令的执行过程示例</p>
<p>SETRANGE 命令执行之前的字符串值</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_37f5b78322a5425bb5a69958d0106d34_r.png" alt></p>
<p>将字符串值扩展至 41 字节长</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_0735452ba1acc96c69aa30dc7248d6b5_r.png" alt></p>
<p>对字符串值进行设置</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_5f0730a440ec29454fd55bbd17a2c20c_r.png" alt></p>
<p>在值里面填充空字节</p>
<p>SETRANGE 命令除了会根据用户给定的新内容自动扩展字符串值之外， 还会根据用户给定的 index 索引扩展字符串： 当用户给定的 index 索引超出字符串值的长度时， 字符串值末尾直到索引 index-1 之间的部分将使用空字节进行填充， 换句话说， 这些字节的所有二进制位都会被设置为 0 。</p>
<p>举个例子， 对于字符串键 greeting 来说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET greeting</span><br><span class="line">&quot;hello&quot;</span><br></pre></td></tr></table></figure>
<p>当我们执行以下命令时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETRANGE greeting 10 &quot;world&quot;</span><br><span class="line">(integer) 15</span><br></pre></td></tr></table></figure>
<p>SETRANGE 命令会先将字符串值扩展为 15 个字节长， 然后将 “hello” 末尾直到索引 9 之间的所有字节都填充为空字节， 最后再将索引 10 到索引 14 的内容设置为 “world” 。 图 2-9 展示了这个扩展、填充、最后设置的过程。</p>
<p>执行 SETRANGE 之前的字符串值</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_a3d81e017a8f2af42e2d061043d41d8b_r.png" alt></p>
<p>将字符串值从 5 个字节扩展至 15 个字节</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_e9c117de52d6f0159be1139770063d74_r.png" alt></p>
<p>使用空字节填充索引 5 至索引 9</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_44914a15f62002ef0fd1fadd67a4b63e_r.png" alt></p>
<p>将索引 10 至索引 14 的内容设置为 “world”</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_96e7daac2cf2f0ca1216f111ff2a01d4_r.png" alt></p>
<p>通过执行 GET 命令， 我们可以取得 greeting 键在执行 SETRANGE 命令之后的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET greeting</span><br><span class="line">&quot;hello\x00\x00\x00\x00\x00world&quot;</span><br></pre></td></tr></table></figure>
<p>可以看到， greeting 键的值现在包含了多个 \x00 符号， 而每个 \x00 符号就代表一个空字节。</p>
<h1 id="示例：给文章储存程序加上文章长度计数功能和文章预览功能"><a href="#示例：给文章储存程序加上文章长度计数功能和文章预览功能" class="headerlink" title="示例：给文章储存程序加上文章长度计数功能和文章预览功能"></a>示例：给文章储存程序加上文章长度计数功能和文章预览功能</h1><p>在前面的内容中， 我们使用 MSET 、 MGET 等命令构建了一个储存文章信息的程序， 在学习了 STRLEN 命令和 GETRANGE 命令之后， 我们可以给这个文章储存程序加上两个新功能， 其中一个是文章长度计数功能， 而另一个则是文章预览功能：</p>
<ul>
<li><p>文章长度计数功能用于显示文章内容的长度， 读者可以通过这个长度值来了解一篇文章大概有多长， 从而决定是否阅读一篇文章。</p>
</li>
<li><p>文章预览功能则用于显示文章开头的一部分内容， 这些内容可以帮助读者快速地了解文章本身， 并吸引读者进一步阅读整篇文章。</p>
</li>
</ul>
<p>其中文章长度计数功能是通过对文章内容执行 STRLEN 命令来实现的， 而文章预览功能则是通过对文章内容执行 GETRANGE 命令来实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time  <span class="comment"># time() 函数用于获取当前 Unix 时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 省略之前展示过的 __init__()、create() 、update() 等方法……</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_content_len</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        返回文章内容的字节长度。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.client.strlen(self.content_key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_content_preview</span><span class="params">(self, preview_len)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        返回指定长度的文章预览内容。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start_index = <span class="number">0</span></span><br><span class="line">        end_index = preview_len<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.client.getrange(self.content_key, start_index, end_index)</span><br></pre></td></tr></table></figure>
<p>get_content_len() 方法的实现非常简单直接， 没有什么需要说明的。 与此相比， get_content_preview() 方法显得更复杂一些， 让我们来对它进行一些分析。</p>
<p>首先， get_content_preview() 方法会接受一个 preview_len 参数， 用于记录调用者指定的预览长度。 接着程序会根据这个预览长度， 计算出预览内容的起始索引和结束索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start_index = <span class="number">0</span></span><br><span class="line">end_index = preview_len<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>因为预览功能要做的就是返回文章内容的前 preview_len 个字节， 所以上面的这两条赋值语句要做的就是计算并记录文章前 preview_len 个字节所在的索引范围， 其中 start_index 的值总是 0 ， 而 end_index 的值则为 preview_len 减一。 举个例子， 假如用户输入的预览长度为 150 ， 那么 start_index 将被赋值为 0 ， 而 end_index 将被赋值为 149 。</p>
<p>最后， 程序会调用 GETRANGE 命令， 根据上面计算出的两个索引， 从储存着文章内容的字符串键里面取出指定的预览内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.client.getrange(self.content_key, start_index, end_index)</span><br></pre></td></tr></table></figure>
<p>以下代码展示了如何使用文章长度计数功能以及文章预览功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> article <span class="keyword">import</span> Article</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>client = Redis(decode_responses=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>article = Article(client, <span class="number">12345</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>title = <span class="string">"Improving map data on GitHub"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>content = <span class="string">"You've been able to view and diff geospatial data on GitHub for a while, but now, in addition to being able to collaborate on the GeoJSON files you upload to GitHub, you can now more easily contribute to the underlying, shared basemap, that provides your data with context."</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>author = <span class="string">"benbalter"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>article.create(title, content, author)  <span class="comment"># 将一篇比较长的文章储存起来</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>article.get_content_len()               <span class="comment"># 文章总长 273 字节</span></span><br><span class="line"><span class="number">273</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>article.get_content_preview(<span class="number">100</span>)        <span class="comment"># 获取文章前 100 字节的内容</span></span><br><span class="line"><span class="string">"You've been able to view and diff geospatial data on GitHub for a while, but now, in addition to bei"</span></span><br></pre></td></tr></table></figure>
<h1 id="APPEND：追加新内容到值的末尾"><a href="#APPEND：追加新内容到值的末尾" class="headerlink" title="APPEND：追加新内容到值的末尾"></a>APPEND：追加新内容到值的末尾</h1><p>通过调用 APPEND 命令， 用户可以将给定的内容追加到字符串键已有值的末尾：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPEND key suffix</span><br></pre></td></tr></table></figure>
<p>APPEND 命令在执行追加操作之后， 会返回字符串值当前的长度作为返回值。</p>
<p>举个例子， 对于以下这个名为 description 的键来说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET description</span><br><span class="line">&quot;Redis&quot;</span><br></pre></td></tr></table></figure>
<p>我们可以通过执行以下命令， 将字符串 “ is a database” 追加到 description 键已有值的末尾：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; APPEND description &quot; is a database&quot;</span><br><span class="line">(integer) 19    -- 追加操作执行完毕之后，值的长度</span><br></pre></td></tr></table></figure>
<p>以下是 description 键在执行完追加操作之后的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET description</span><br><span class="line">&quot;Redis is a database&quot;</span><br></pre></td></tr></table></figure>
<p>在此之后， 我们可以继续执行以下 APPEND 命令， 将字符串 “ with many different data structure.” 追加到 description 键已有值的末尾：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; APPEND description &quot; with many different data structure.&quot;</span><br><span class="line">(integer) 55</span><br></pre></td></tr></table></figure>
<p>现在， description 键的值又变成了以下这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET description</span><br><span class="line">&quot;Redis is a database with many different data structure.&quot;</span><br></pre></td></tr></table></figure>
<p>description 键的值随着 APPEND 命令的执行而变化</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_9c3eddf72c616aaa2845fc59dfaae420_r.png" alt></p>
<p>处理不存在的键</p>
<p>如果用户给定的键并不存在， 那么 APPEND 命令会先将键的值初始化为空字符串 “” ， 然后再执行追加操作， 最终效果跟使用 SET 命令为键设置值的情况类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET append_msg  -- 键不存在</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; APPEND append_msg &quot;hello&quot;  -- 效果相当于执行 SET append_msg &quot;hello&quot;</span><br><span class="line">(integer) 5</span><br><span class="line"></span><br><span class="line">redis&gt; GET append_msg</span><br><span class="line">&quot;hello&quot;</span><br></pre></td></tr></table></figure>
<p>当键有了值之后， APPEND 又会像平时一样， 将用户给定的值追加到已有值的末尾：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; APPEND append_msg &quot;, how are you?&quot;</span><br><span class="line">(integer) 19</span><br><span class="line"></span><br><span class="line">redis&gt; GET append_msg</span><br><span class="line">&quot;hello, how are you?&quot;</span><br></pre></td></tr></table></figure>
<p>APPEND 的判断过程</p>
<p><img src="https://chanchifeng.com/mindoc/uploads/redis/images/m_3905897f5677ef655046a7705bfb8a43_r.png" alt></p>
<h1 id="示例：储存日志"><a href="#示例：储存日志" class="headerlink" title="示例：储存日志"></a>示例：储存日志</h1><p>很多程序在运行的时候都会生成一些日志， 这些日志记录了程序的运行状态以及执行过的重要操作。</p>
<p>比如说， 以下展示的就是 Redis 服务器运行时输出的一些日志， 这些日志记录了 Redis 开始运行的时间， 载入数据库所耗费的时长， 接收客户端连接所使用的端口号， 以及进行数据持久化操作的时间点等信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6066:M 06 Jul 17:40:49.611 # Server started, Redis version 3.1.999</span><br><span class="line">6066:M 06 Jul 17:40:49.627 * DB loaded from disk: 0.016 seconds</span><br><span class="line">6066:M 06 Jul 17:40:49.627 * The server is now ready to accept connections on port 6379</span><br><span class="line">6066:M 06 Jul 18:29:20.009 * DB saved on disk</span><br></pre></td></tr></table></figure>
<p>为了记录程序运行的状态， 又或者为了对日志进行分析， 我们有时候会需要把程序生成的日志储存起来。</p>
<p>比如说， 我们可以通过使用 SET 命令， 将日志的生成时间用作键、日志的内容用作值， 把上面展示的日志储存到多个字符串键里面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET &quot;06 Jul 17:40:49.611&quot; &quot;# Server started, Redis version 3.1.999&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET &quot;06 Jul 17:40:49.627&quot; &quot;* DB loaded from disk: 0.016 seconds&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET &quot;06 Jul 17:40:49.627&quot; &quot;* The server is now ready to accept connections on port 6379&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET &quot;06 Jul 18:29:20.009&quot; &quot;* DB saved on disk&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>遗憾的是， 这种日志储存方式并不理想， 它的主要问题有两个：</p>
<ol>
<li><p>这种方法需要在数据库里面创建非常多的键。 因为 Redis 每创建一个键就需要消耗一定的额外资源（overhead）来对键进行维护， 所以键的数量越多， 消耗的额外资源就会越多。</p>
</li>
<li><p>这种方法将全部日志分散地储存在不同的键里面， 当程序想要对特定的日志进行分析的时候， 它就需要花费额外的时间和资源去查找指定的日志， 这给分析操作带来了额外的麻烦和资源消耗。</p>
</li>
</ol>
<p>展示了另一种更为方便和高效的日志储存方式， 这个程序会把同一天之内产生的所有日志都储存在同一个字符串键里面， 从而使得用户可以非常高效地取得指定日期内产生的所有日志。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LOG_SEPARATOR = <span class="string">"\n"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, client, key)</span>:</span></span><br><span class="line">        self.client = client</span><br><span class="line">        self.key = key</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, new_log)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        将给定的日志储存起来。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new_log += LOG_SEPARATOR</span><br><span class="line">        self.client.append(self.key, new_log)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_all</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        以列表形式返回所有日志。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        all_logs = self.client.get(self.key)</span><br><span class="line">        <span class="keyword">if</span> all_logs <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            log_list = all_logs.split(LOG_SEPARATOR)</span><br><span class="line">            log_list.remove(<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> log_list</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<p>日志储存程序的 add() 方法负责将新日志储存起来。 这个方法首先会将分隔符追加到新日志的末尾：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_log += LOG_SEPARATOR</span><br></pre></td></tr></table></figure>
<p>然后调用 APPEND 命令， 将新日志追加到已有日志的末尾：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.client.append(self.key, new_log)</span><br></pre></td></tr></table></figure>
<p>举个例子， 如果用户输入的日志是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"this is log1"</span></span><br></pre></td></tr></table></figure>
<p>那么 add() 方法首先会把分隔符 “\n” 追加到这行日志的末尾， 使之变成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"this is log1\n"</span></span><br></pre></td></tr></table></figure>
<p>然后调用以下命令， 将新日志追到已有日志的末尾：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPEND key <span class="string">"this is log1\n"</span></span><br></pre></td></tr></table></figure>
<p>负责获取所有日志的 get_all() 方法比较复杂， 因为它不仅需要从字符串键里面取出包含了所有日志的字符串值， 还需要从这个字符串值里面分割出每一条日志。 首先， 这个方法使用 GET 命令从字符串键里面取出包含了所有日志的字符串值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_logs = self.client.get(self.key)</span><br></pre></td></tr></table></figure>
<p>接着， 程序会检查 all_logs 这个值是否为空， 如果为空则表示没有日志被储存， 程序直接返回空列表 [] 作为 get_all() 方法的执行结果； 另一方面， 如果值不为空， 那么程序将调用 Python 的 split() 方法对字符串值进行分割， 并将分割结果储存到 log_list 列表里面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_list = all_logs.split(LOG_SEPARATOR)</span><br></pre></td></tr></table></figure>
<p>因为 split() 方法会在结果中包含一个空字符串， 而我们并不需要这个空字符串， 所以程序还会调用 remove() 方法， 将空字符串从分割结果中移除， 使得 log_list 列表里面只保留被分割的日志：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_list.remove(<span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<p>在此之后， 程序只需要将包含了多条日志的 log_list 列表返回给调用者就可以了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> log_list</span><br></pre></td></tr></table></figure>
<p>举个例子， 假设我们使用 add() 方法， 在一个字符串键里面储存了 “this is log1” 、 this is log2” 、 this is log3” 这三条日志， 那么 get_all() 方法在使用 GET 命令获取字符串键的值时， 将得到以下结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"this is log1\nthis is log2\nthis is log3"</span></span><br></pre></td></tr></table></figure>
<p>在使用 split(LOG_SEPARATOR) 方法对这个结果进行分割之后， 程序将得到一个包含四个元素的列表， 其中列表最后的元素为空字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"this is log1"</span>, <span class="string">"this is log2"</span>, <span class="string">"this is log3"</span>, <span class="string">""</span>]</span><br></pre></td></tr></table></figure>
<p>在调用 remove(“”) 方法移除列表中的空字符串之后， 列表里面就只会包含被储存的日志：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"this is log1"</span>, <span class="string">"this is log2"</span>, <span class="string">"this is log3"</span>]</span><br></pre></td></tr></table></figure>
<p>这时 get_all() 方法只需要把这个列表返回给调用者就可以了。</p>
<p>以下代码展示了这个日志储存程序的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from redis import Redis</span><br><span class="line">&gt;&gt;&gt; from log import Log</span><br><span class="line">&gt;&gt;&gt; client = Redis(decode_responses=True)</span><br><span class="line">&gt;&gt;&gt; # 按日期归类日志</span><br><span class="line">&gt;&gt;&gt; log = Log(client, &quot;06 Jul&quot;)</span><br><span class="line">&gt;&gt;&gt; # 储存日志</span><br><span class="line">&gt;&gt;&gt; log.add(&quot;17:40:49.611 # Server started, Redis version 3.1.999&quot;)</span><br><span class="line">&gt;&gt;&gt; log.add(&quot;17:40:49.627 * DB loaded from disk: 0.016 seconds&quot;)</span><br><span class="line">&gt;&gt;&gt; log.add(&quot;17:40:49.627 * The server is now ready to accept connections on port 6379&quot;)</span><br><span class="line">&gt;&gt;&gt; log.add(&quot;18:29:20.009 * DB saved on disk&quot;)</span><br><span class="line">&gt;&gt;&gt; # 以列表形式返回所有日志</span><br><span class="line">&gt;&gt;&gt; log.get_all()</span><br><span class="line">[&apos;17:40:49.611 # Server started, Redis version 3.1.999&apos;, &apos;17:40:49.627 * DB loaded from disk: 0.016 seconds&apos;, &apos;17:40:49.627 * The server is now ready to accept connections on port 6379&apos;, &apos;18:29:20.009 * DB saved on disk&apos;]</span><br><span class="line">&gt;&gt;&gt; # 单独打印每条日志</span><br><span class="line">&gt;&gt;&gt; for i in log.get_all():</span><br><span class="line">...   print(i)</span><br><span class="line">...</span><br><span class="line">17:40:49.611 # Server started, Redis version 3.1.999</span><br><span class="line">17:40:49.627 * DB loaded from disk: 0.016 seconds</span><br><span class="line">17:40:49.627 * The server is now ready to accept connections on port 6379</span><br><span class="line">18:29:20.009 * DB saved on disk</span><br></pre></td></tr></table></figure>
<h1 id="使用字符串键储存数字值"><a href="#使用字符串键储存数字值" class="headerlink" title="使用字符串键储存数字值"></a>使用字符串键储存数字值</h1><p>每当用户将一个值储存到字符串键里面的时候， Redis 都会对这个值进行检测， 如果这个值能够被解释为以下两种类型的其中一种， 那么 Redis 就会把这个值当做数字来处理：</p>
<ul>
<li><p>一种是能够使用 C 语言的 long long int 类型储存的整数， 在大多数系统中， 这种类型储存的都是 64 位长度的有符号整数， 取值范围介于 -9223372036854775808 和 9223372036854775807 之间；</p>
</li>
<li><p>第二种是能够使用 C 语言的 long double 类型储存的浮点数， 在大多数系统中， 这种类型储存的都是 128 位长度的有符号浮点数， 取值范围介于 3.36210314311209350626e-4932 和 1.18973149535723176502e+4932L 之间。</p>
</li>
</ul>
<p>一些能够被 Redis 解释为数字的例子</p>
<table>
<thead>
<tr>
<th>值</th>
<th>Redis 解释这个值的方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>10086</td>
<td>解释为整数。</td>
</tr>
<tr>
<td>+894</td>
<td>解释为整数。</td>
</tr>
<tr>
<td>-123</td>
<td>解释为整数。</td>
</tr>
<tr>
<td>3.14</td>
<td>解释为浮点数。</td>
</tr>
<tr>
<td>+2.56</td>
<td>解释为浮点数。</td>
</tr>
<tr>
<td>-5.12</td>
<td>解释为浮点数。</td>
</tr>
<tr>
<td>12345678901234567890</td>
<td>这个值虽然是整数， 但是因为它的大小超出了 long long int 类型能够容纳的范围， 所以只能被解释为字符串。</td>
</tr>
<tr>
<td>3.14e5</td>
<td>因为 Redis 不能解释使用科学记数法表示的浮点数， 所以这个值只能被解释为字符串。</td>
</tr>
<tr>
<td>“one”</td>
<td>解释为字符串。</td>
</tr>
<tr>
<td>“123abc”</td>
<td>解释为字符串。</td>
</tr>
</tbody>
</table>
<h1 id="INCRBY、DECRBY：对整数值执行加法操作和减法操作"><a href="#INCRBY、DECRBY：对整数值执行加法操作和减法操作" class="headerlink" title="INCRBY、DECRBY：对整数值执行加法操作和减法操作"></a>INCRBY、DECRBY：对整数值执行加法操作和减法操作</h1><p>当字符串键储存的值能够被 Redis 解释为整数时， 用户就可以通过 INCRBY 命令和 DECRBY 命令， 对被储存的整数值执行加法操作或是减法操作。</p>
<p>INCRBY 命令用于为整数值加上指定的整数增量， 并返回键在执行加法操作之后的值：</p>
<p><code>INCRBY key increment</code></p>
<p>以下代码展示了如何使用 INCRBY 命令去增加一个字符串键的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET number 100</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET number</span><br><span class="line">&quot;100&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBY number 300     -- 将键的值加上 300</span><br><span class="line">(integer) 400</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBY number 256     -- 将键的值加上 256</span><br><span class="line">(integer) 656</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBY number 1000    -- 将键的值加上 1000</span><br><span class="line">(integer) 1656</span><br><span class="line"></span><br><span class="line">redis&gt; GET number</span><br><span class="line">&quot;1656&quot;</span><br></pre></td></tr></table></figure>
<p>与 INCRBY 命令的作用正好相反， DECRBY 命令用于为整数值减去指定的整数减量， 并返回键在执行减法操作之后的值：</p>
<p><code>DECRBY key increment</code></p>
<p>以下代码展示了如何使用 DECRBY 命令去减少一个字符串键的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET number 10086</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET number</span><br><span class="line">&quot;10086&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; DECRBY number 300     -- 将键的值减去 300</span><br><span class="line">(integer) 9786</span><br><span class="line"></span><br><span class="line">redis&gt; DECRBY number 786     -- 将键的值减去 786</span><br><span class="line">(integer) 9000</span><br><span class="line"></span><br><span class="line">redis&gt; DECRBY number 5500    -- 将键的值减去 5500</span><br><span class="line">(integer) 3500</span><br><span class="line"></span><br><span class="line">redis&gt; GET number</span><br><span class="line">&quot;3500&quot;</span><br></pre></td></tr></table></figure>
<p>类型限制</p>
<p>当字符串键的值不能被 Redis 解释为整数时， 对键执行 INCRBY 命令或是 DECRBY 命令将返回一个错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET pi 3.14</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBY pi 100    -- 不能对浮点数值执行</span><br><span class="line">(error) ERR value is not an integer or out of range</span><br><span class="line"></span><br><span class="line">redis&gt; SET message &quot;hello world&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBY message    -- 不能对字符串值执行</span><br><span class="line">(error) ERR wrong number of arguments for &apos;incrby&apos; command</span><br><span class="line"></span><br><span class="line">redis&gt; SET big-number 123456789123456789123456789</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBY big-number 100    -- 不能对超过 64 位长度的整数执行</span><br><span class="line">(error) ERR value is not an integer or out of range</span><br></pre></td></tr></table></figure>
<p>另外需要注意的一点是， INCRBY 和 DECRBY 的增量和减量也必须能够被 Redis 解释为整数， 使用其他类型的值作为增量或减量将返回一个错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; INCRBY number 3.14    -- 不能使用浮点数作为增量</span><br><span class="line">(error) ERR value is not an integer or out of range</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBY number &quot;hello world&quot;    -- 不能使用字符串值作为增量</span><br><span class="line">(error) ERR value is not an integer or out of range</span><br></pre></td></tr></table></figure>
<p>处理不存在的键</p>
<p>当 INCRBY 命令或 DECRBY 命令遇到不存在的键时， 命令会先将键的值初始化为 0 ， 然后再执行相应的加法操作或减法操作。</p>
<p>以下代码展示了 INCRBY 命令是如何处理不存在的键 x 的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET x    -- 键 x 不存在</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBY x 123    -- 先将键 x 的值初始化为 0 ，然后再执行加上 123 的操作</span><br><span class="line">(integer) 123</span><br><span class="line"></span><br><span class="line">redis&gt; GET x</span><br><span class="line">&quot;123&quot;</span><br></pre></td></tr></table></figure>
<p>而以下代码则展示了 DECRBY 命令是如何处理不存在的键 y 的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET y    -- 键 y 不存在</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; DECRBY y 256    -- 先将键 y 的值初始化为 0 ，然后再执行减去 256 的操作</span><br><span class="line">(integer) -256</span><br><span class="line"></span><br><span class="line">redis&gt; GET y</span><br><span class="line">&quot;-256&quot;</span><br></pre></td></tr></table></figure>
<h1 id="INCR、DECR：对整数值执行加一操作和减一操作"><a href="#INCR、DECR：对整数值执行加一操作和减一操作" class="headerlink" title="INCR、DECR：对整数值执行加一操作和减一操作"></a>INCR、DECR：对整数值执行加一操作和减一操作</h1><p>因为对整数值执行加一操作或是减一操作的场景经常会出现， 所以为了能够更方便地执行这两个操作， Redis 分别提供了用于执行加一操作的 INCR 命令以及用于执行减一操作的 DECR 命令。</p>
<p>INCR 命令的作用就是将字符串键储存的整数值加上一， 它的效果相当于执行 INCRBY key 1 ：</p>
<p><code>INCR key</code></p>
<p>而 DECR 命令的作用就是将字符串键储存的整数值减去一， 它的效果相当于执行 DECRBY key 1 ：</p>
<p><code>DECR key</code></p>
<p>以下代码展示了 INCR 命令和 DECR 命令的作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET counter 100</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCR counter    -- 对整数值执行加一操作</span><br><span class="line">(integer) 101</span><br><span class="line"></span><br><span class="line">redis&gt; INCR counter</span><br><span class="line">(integer) 102</span><br><span class="line"></span><br><span class="line">redis&gt; INCR counter</span><br><span class="line">(integer) 103</span><br><span class="line"></span><br><span class="line">redis&gt; DECR counter    -- 对整数值执行减一操作</span><br><span class="line">(integer) 102</span><br><span class="line"></span><br><span class="line">redis&gt; DECR counter</span><br><span class="line">(integer) 101</span><br><span class="line"></span><br><span class="line">redis&gt; DECR counter</span><br><span class="line">(integer) 100</span><br></pre></td></tr></table></figure>
<p>除了增量和减量被固定为一之外， INCR 命令和 DECR 命令的其他方面与 INCRBY 命令以及 DECRBY 命令完全相同。</p>
<h1 id="INCRBYFLOAT：对数字值执行浮点数加法操作"><a href="#INCRBYFLOAT：对数字值执行浮点数加法操作" class="headerlink" title="INCRBYFLOAT：对数字值执行浮点数加法操作"></a>INCRBYFLOAT：对数字值执行浮点数加法操作</h1><p>除了用于执行整数加法操作的 INCR 命令以及 INCRBY 命令之外， Redis 还提供了用于执行浮点数加法操作的 INCRBYFLOAT 命令：</p>
<p><code>INCRBYFLOAT key increment</code></p>
<p>INCRBYFLOAT 命令可以把一个浮点数增量加到字符串键储存的数字值上面， 并返回键在执行加法操作之后的数字值作为命令的返回值。</p>
<p>以下代码展示了如何使用 INCRBYFLOAT 命令去增加一个浮点数的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET decimal 3.14    -- 一个储存着浮点数值的键</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET decimal</span><br><span class="line">&quot;3.14&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBYFLOAT decimal 2.55    -- 将键 decimal 的值加上 2.55</span><br><span class="line">&quot;5.69&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; GET decimal</span><br><span class="line">&quot;5.69&quot;</span><br></pre></td></tr></table></figure>
<p>处理不存在的键<br>INCRBYFLOAT 命令在遇到不存在的键时， 会先将键的值初始化为 0 ， 然后再执行相应的加法操作。</p>
<p>在以下展示的代码里面， INCRBYFLOAT 命令就是先把 x-point 键的值初始化为 0 ， 然后再执行加法操作的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET x-point    -- 不存在的键</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBYFLOAT x-point 12.7829</span><br><span class="line">&quot;12.7829&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; GET x-point</span><br><span class="line">&quot;12.7829&quot;</span><br></pre></td></tr></table></figure>
<p>使用 INCRBYFLOAT 执行浮点数减法操作<br>Redis 为 INCR 命令提供了相应的减法版本 DECR 命令， 也为 INCRBY 命令提供了相应的减法版本 DECRBY 命令， 但是并没有为 INCRBYFLOAT 命令提供相应的减法版本， 因此用户只能通过给 INCRBYFLOAT 命令传入负数增量来执行浮点数减法操作。</p>
<p>以下代码展示了如何使用 INCRBYFLOAT 命令执行浮点数减法计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET pi 3.14</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET pi</span><br><span class="line">&quot;3.14&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBYFLOAT pi -1.1    -- 值减去 1.1</span><br><span class="line">&quot;2.04&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBYFLOAT pi -0.7    -- 值减去 0.7</span><br><span class="line">&quot;1.34&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBYFLOAT pi -1.3    -- 值减去 1.3</span><br><span class="line">&quot;0.04&quot;</span><br></pre></td></tr></table></figure>
<p>INCRBYFLOAT 与整数值</p>
<p>INCRBYFLOAT 命令对于类型限制的要求比 INCRBY 命令和 INCR 命令要宽松得多， INCRBYFLOAT 命令不仅可以用于处理浮点数值， 它还可以用于处理整数值：</p>
<ul>
<li><p>INCRBYFLOAT 命令既可用于浮点数值， 也可以用于整数值。</p>
</li>
<li><p>INCRBYFLOAT 命令的增量既可以是浮点数， 又可以是整数。</p>
</li>
<li><p>当 INCRBYFLOAT 命令的执行结果可以表示为整数时， 命令的执行结果将以整数形式储存。</p>
</li>
</ul>
<p>以下代码展示了如何使用 INCRBYFLOAT 去处理一个储存着整数值的键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET pi 1    -- 创建一个整数值</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET pi</span><br><span class="line">&quot;1&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBYFLOAT pi 2.14</span><br><span class="line">&quot;3.14&quot;</span><br></pre></td></tr></table></figure>
<p>以下代码展示了如何使用整数值作为 INCRBYFLOAT 命令的增量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET pi 3.14</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET pi</span><br><span class="line">&quot;3.14&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBYFLOAT pi 20    -- 增量为整数值</span><br><span class="line">&quot;23.14&quot;</span><br></pre></td></tr></table></figure>
<p>而以下代码则展示了 INCRBYFLOAT 命令是如何把计算结果储存为整数的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET pi 3.14</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET pi</span><br><span class="line">&quot;3.14&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBYFLOAT pi 0.86    -- 计算结果被储存为整数</span><br><span class="line">&quot;4&quot;</span><br></pre></td></tr></table></figure>
<p>小数位长度限制</p>
<p>虽然 Redis 并不限制字符串键储存的浮点数的小数位长度， 但是在使用 INCRBYFLOAT 命令处理浮点数的时候， 命令最多只会保留计算结果小数点后的 17 位数字， 超过这个范围的小数将被截断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET i</span><br><span class="line">&quot;0.01234567890123456789&quot;    -- 这个数字的小数部分有 20 位长</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBYFLOAT i 0</span><br><span class="line">&quot;0.01234567890123457&quot;    -- 执行加法操作之后，小数部分只保留了 17 位</span><br></pre></td></tr></table></figure>
<h1 id="示例：ID-生成器"><a href="#示例：ID-生成器" class="headerlink" title="示例：ID 生成器"></a>示例：ID 生成器</h1><p>在构建应用程序的时候， 我们经常会用到各式各样的 ID （identifier，标识符）。 比如说， 储存用户信息的程序在每次出现一个新用户的时候就需要创建一个新的用户 ID ， 而博客程序在作者每次发表一篇新文章的时候也需要创建一个新的文章 ID ， 诸如此类。</p>
<p>ID 通常会以数字形式出现， 并且通过递增的方式来创建出新的 ID 。 比如说， 如果当前最新的 ID 值为 10086 ， 那么下一个 ID 就应该是 10087 ， 而再下一个 ID 则是 10088 ， 以此类推。</p>
<p>代码清单 2-6 展示了一个使用字符串键实现的 ID 生成器， 这个生成器通过执行 INCR 命令来产生新的 ID ， 并且它还可以通过执行 SET 命令来保留指定数字之前的 ID ， 从而避免用户为了得到某个指定的 ID 而生成大量无效 ID 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, client, key)</span>:</span></span><br><span class="line">    self.client = client</span><br><span class="line">    self.key = key</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    生成并返回下一个 ID 。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> self.client.incr(self.key)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reserve</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    保留前 n 个 ID ，使得之后执行的 produce() 方法产生的 ID 都大于 n 。</span></span><br><span class="line"><span class="string">    为了避免 produce() 方法产生重复 ID ，</span></span><br><span class="line"><span class="string">    这个方法只能在 produce() 方法和 reserve() 方法都没有执行过的情况下使用。</span></span><br><span class="line"><span class="string">    这个方法在 ID 被成功保留时返回 True ，</span></span><br><span class="line"><span class="string">    在 produce() 方法或 reserve() 方法已经执行过而导致保留失败时返回 False 。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    result = self.client.set(self.key, n, nx=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">is</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>在这个 ID 生成器程序中， produce() 方法要做的就是调用 INCR 命令， 对字符串键储存的整数值执行加一操作， 并将执行加法操作之后得到的新值用作 ID 。</p>
<p>另一方面， 用于保留指定 ID 的 reserve() 方法是通过执行 SET 命令为键设置值来实现的： 当用户把一个字符串键的值设置为 N 之后， 对这个键执行 INCR 命令总是会返回比 N 更大的值， 因此在效果上就相当于把所有小于等于 N 的 ID 都保留下来了。</p>
<p>需要注意的是， 这种保留 ID 的方法只能在字符串键还没有值的情况下使用， 如果用户已经使用过 produce() 方法来生成 ID ， 又或者已经执行过 reserve() 方法来保留 ID ， 那么再使用 SET 命令去设置 ID 值可能就会导致 produce() 方法产生出一些已经用过的 ID ， 并因此引发 ID 冲突。</p>
<p>为此， reserve() 方法在设置字符串键时使用了带有 NX 选项的 SET 命令， 从而确保了对键的设置操作只会在键不存在的情况下执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.client.set(self.key, n, nx=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>以下代码展示了这个 ID 生成器的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from redis import Redis</span><br><span class="line">&gt;&gt;&gt; from id_generator import IdGenerator</span><br><span class="line">&gt;&gt;&gt; client = Redis(decode_responses=True)</span><br><span class="line">&gt;&gt;&gt; id_generator = IdGenerator(client, &quot;user::id&quot;)</span><br><span class="line">&gt;&gt;&gt; id_generator.reserve(1000000)  # 保留前一百万个 ID</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; id_generator.produce()         # 生成 ID ，这些 ID 的值都大于一百万</span><br><span class="line">1000001</span><br><span class="line">&gt;&gt;&gt; id_generator.produce()</span><br><span class="line">1000002</span><br><span class="line">&gt;&gt;&gt; id_generator.produce()</span><br><span class="line">1000003</span><br><span class="line">&gt;&gt;&gt; id_generator.reserve(1000)     # 键已经有值，无法再次执行 reserve() 方法</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>摘抄<a href="http://redisguide.com/introduction.html#id6" title="Redis使用手册" target="_blank" rel="noopener">Redis使用手册</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-03-12</span><i class="fa fa-tag"></i></div></div></div></div><div class="cc"><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a></div><div class="cc_tips">本作品采用<a href="http://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a>进行许可。
<span id="busuanzi_container_page_pv"></span>本文总阅读量：<span id="busuanzi_value_page_pv"></span></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/03/14/202003142239/" title="React - 使用技巧">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/03/12/202003132305/" title="idea - 使用技巧">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/busuanzi/busuanzi.pure.mini.js"></script></body></html>